<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Matching Algorithm Visualization</title>
    <style>
      @font-face {
        font-family: "Geist";
        src: url("fonts/Geist-Bold.otf") format("opentype");
        font-weight: normal;
        font-style: normal;
      }

      @font-face {
        font-family: "GeistMono";
        src: url("fonts/GeistMono-Regular.otf") format("opentype");
        font-weight: normal;
        font-style: normal;
      }

      :root {
        --bg-color: #f5f5f5;
        --text-color: #222;
        --box-bg: #ffffff;
        --border-color: #ccc;
        --grid-color: rgba(125, 125, 125, 0.75);
        --button-bg: #ccc;
      }

      .dark-mode {
        --bg-color: #222;
        --text-color: #f5f5f5;
        --box-bg: #333;
        --border-color: #444;
        --grid-color: rgba(255, 255, 255, 0.2);
        --button-bg: #444;
      }

      body {
        text-align: center;
        background: var(--bg-color);
        color: var(--text-color);
        transition: background 0.3s ease, color 0.3s ease;
      }

      canvas {
        background: var(--box-bg);
        display: block;
        margin: auto;
        border: 1px solid var(--border-color);
        cursor: url("icons/scan.png") 16 16, zoom-in;

        border-radius: 12px;
        overflow: hidden;
      }

      canvas {
        border-color: var(--border-color);
      }

      .tab-container {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 20px;
        margin-bottom: 10px;
      }

      .tab-group {
        display: flex;
        gap: 10px;
      }

      .tab-icons {
        display: flex;
        gap: 10px;
        margin-left: 20px;
      }

      .title {
        font-family: "Geist", sans-serif;
        font-size: 28px;
        font-weight: bold;
        color: var(--text-color);
        text-align: center;
        margin: 20px 0;
        padding: 10px;
        background: var(--text-color);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        letter-spacing: 1px;
      }

      .title-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
      }

      .title2 {
        font-family: "GeistMono", monospace;
        font-size: 18px;
        font-weight: bold;
        max-width: 650px;
        margin: 10px 0 20px 0;
        color: black;
      }

      .highlight {
        color: #1e90ff;
      }

      .tab {
        padding: 6px 10px;
        margin: 5px;
        font-family: "Geist", sans-serif;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        color: white;
        transition: background 0.3s, transform 0.1s;
        border: 1px solid var(--border-color);
      }

      .tab:nth-child(1) {
        background-color: #704bfe;
      }
      .tab:nth-child(2) {
        background-color: #3a86ff;
      }
      .tab:nth-child(3) {
        background-color: #ff924c;
      }
      .tab:nth-child(4) {
        background-color: #4cd38a;
      }

      .tab:hover {
        transform: scale(1.05);
        opacity: 0.8;
      }

      .tab-icons .tab {
        background: none;
        padding: 0;
        border: none;
        display: flex;
        align-items: center;
      }

      .tab-icons img {
        height: 28px;
        width: auto;
        vertical-align: middle;
        cursor: pointer;
        transition: transform 0.3s ease-in-out;
      }

      .tab-icons .tab:first-child img,
      .tab-icons .tab:nth-child(2) img {
        height: 22px;
      }

      .tab-icons .tab:last-child:hover img {
        transform: rotate(-360deg);
      }

      .dark-mode .tab-icons img {
        filter: invert(1);
      }

        .dark-mode canvas {
    cursor: url("icons/scan-inverted.png") 16 16, zoom-in;
  }


      .loading-box {
        border: 1px solid var(--border-color);
        padding: 10px;
        border-radius: 6px;
        text-align: center;
        margin-top: 20px;
        margin-bottom: 20px;
        display: inline-block;
        width: 120px;
        background: var(--box-bg);
      }

      .loading-container {
        width: 80px;
        background-color: var(--border-color);
        border-radius: 4px;
        height: 8px;
        overflow: hidden;
        margin: 10px auto 14px auto;
        opacity: 0;
        transition: opacity 0.3s ease-in-out;
      }

      .loading-bar {
        height: 100%;
        width: 0%;
        background-color: #50c878;
        transition: width 2s ease-in-out;
        border-radius: 4px;
      }

      .percent-text {
        font-size: 14px;
        font-weight: bold;
        color: var(--text-color);
        margin-top: 5px;
      }

      .description-box,
      #cluster-info-box {
        font-family: "GeistMono", monospace;
        font-size: 14px;
        color: var(--text-color);
        background: var(--box-bg);
        border: 1px solid var(--border-color);
        padding: 10px;
        margin: 10px auto;
        width: 600px;
        text-align: center;
        border-radius: 5px;
        box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.1);
        transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        opacity: 0;
        visibility: hidden;
        border-radius: 12px;
        overflow: hidden;
      }
      #cluster-info-box strong {
        font-family: "Geist-Bold", sans-serif;
        font-weight: normal;
      }

      #cluster-info-box {
        width: 730px;
        margin: -40px auto 40px auto !important;
      }

      #typing-text {
        color: var(--text-color);
      }

      .dark-mode #cluster-info-box {
        background: var(--box-bg);
        color: var(--text-color);
        border-color: var(--border-color);
      }

      .dark-mode #cluster-info-box strong {
        color: var(--text-color);
      }

      .dark-mode #cluster-info-box span {
        color: var(--text-color) !important;
      }

      #cluster-progress-container {
        font-family: "GeistMono", monospace;
        font-size: 16px;
        font-weight: bold;
        color: var(--text-color);
        background: var(--box-bg);
        border: 1px solid var(--border-color);
        padding: 8px 14px;
        border-radius: 6px;
        margin-left: 20px;
        transition: background 0.3s ease-in-out;
      }
    </style>
  </head>
  <body>
    <div class="title-container">
      <h1 class="title">Algorithms to uncover structure in financial data</h1>
      <h5 class="title2" id="typing-text"></h5>
    </div>

    <div class="tab-container">
      <div class="tab-group">
        <button onclick="formClusters(['A'])" class="tab">1</button>
        <button onclick="formClusters(['B'])" class="tab">2</button>
        <button onclick="formClusters(['C', 'D'])" class="tab">3</button>
        <button onclick="formClusters(['E', 'F', 'G', 'H'])" class="tab">
          4
        </button>
      </div>

      <div class="tab-icons">
        <button onclick="colorClusters()" class="tab">
          <img src="icons/brush.png" />
        </button>
        <button onclick="toggleDarkMode()" class="tab">
          <img id="darkModeIcon" src="icons/moon.png" />
        </button>
        <button onclick="scatterNodes()" class="tab">
          <img src="icons/reset.png" />
        </button>
      </div>

      <div id="cluster-progress-container">
        <span>Matches Found: <strong id="cluster-progress">0.00%</strong></span>
      </div>
    </div>

    <canvas id="canvas"></canvas>
    <div id="description-box" class="description-box"></div>
    <div id="cluster-info-box" class="description-box"></div>

    <script>
      let draggingNode = null;
      let offsetX = 0;
      let offsetY = 0;

      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      canvas.width = 750;
      canvas.height = 750;

      const colors = {
        person: "black",
        company: "black",
        id: "lightgray",
        name: "black",
        firmID: "lightgray",
        analystID: "lightgray",
        firm: "black",
        documentID: "black",
        report: "black",
        estimid: "lightgray",
      };

      const descriptions = {
        1: "Cosine: vectorized string comparisons (Max)",
        2: "Fuzzy: edit distance string comparisons (Ben)",
        3: "Grouping: identifies structural patterns (Theo + Arjun)",
        4: "Frequency: forms an internal probability distribution (Joseph + Connor)",
      };

      const descriptionBox = document.getElementById("description-box");

      document.querySelectorAll(".tab").forEach((button, index) => {
        const buttonIndex = index + 1;
        if (buttonIndex <= 4) {
          button.style.backgroundColor = "#ccc";

          button.addEventListener("mouseover", () => {
            button.style.backgroundColor = getButtonColor(buttonIndex);
            descriptionBox.textContent = descriptions[buttonIndex] || "";
            descriptionBox.style.opacity = "1";
            descriptionBox.style.visibility = "visible";
          });

          button.addEventListener("mouseleave", () => {
            if (
              !buttonGroups[buttonIndex].some((cluster) =>
                nodes.some(
                  (node) =>
                    node.cluster === cluster &&
                    node.targetX !== null &&
                    node.targetY !== null
                )
              )
            ) {
              button.style.backgroundColor = "#ccc";
            }

            setTimeout(() => {
              if (!document.querySelector(".tab:hover")) {
                descriptionBox.style.opacity = "0";
                descriptionBox.style.visibility = "hidden";
              }
            }, 10);
          });
        }
      });

      function animatePercentage(targetPercentage) {
        let progressElement = document.getElementById("cluster-progress");
        let currentPercentage = parseFloat(progressElement.innerText) || 0;
        let step = (targetPercentage - currentPercentage) / 30;

        let count = 0;
        let interval = setInterval(() => {
          if (count >= 30) {
            clearInterval(interval);
            updatePercentageDisplay(targetPercentage, true);
          } else {
            currentPercentage += step;
            updatePercentageDisplay(currentPercentage, false);
            count++;
          }
        }, 20);
      }

      function updatePercentageDisplay(percentage, isFinal) {
        let progressElement = document.getElementById("cluster-progress");
        let formattedPercentage = formatPercentage(percentage);

        if (isFinal && percentage >= 100) {
          progressElement.style.color = "#50C878";
          progressElement.style.fontWeight = "bold";
          progressElement.innerHTML = `${formattedPercentage}`;
        } else {
          progressElement.style.color = "";
          progressElement.style.fontWeight = "normal";
          progressElement.innerText = formattedPercentage;
        }
      }

      function formatPercentage(value) {
        return `${value.toFixed(2)}%`;
      }

      function checkFullMatch(percentage) {
        let progressElement = document.getElementById("cluster-progress");
        if (percentage >= 100) {
          progressElement.style.color = "#50C878";
          progressElement.style.fontWeight = "bold";
        } else {
          progressElement.style.color = "";
          progressElement.style.fontWeight = "normal";
        }
      }

      function formatPercentage(value) {
        return `${value.toFixed(2)}%`;
      }

      document.addEventListener("DOMContentLoaded", function () {
        const text = `Finding insights in complex financial data, improving data quality, automating data collection, and deanonymizing analyst reporting to foster accountability and transparency.`;

        const highlightWords = [
          "Finding insights",
          "improving data quality",
          "automating",
          "accountability",
          "transparency",
        ];
        const highlightColor = "#1e90ff";

        const targetElement = document.getElementById("typing-text");
        let index = 0;

        function typeNextChar() {
          if (index < text.length) {
            let currentText = text.slice(0, index + 1);

            highlightWords.forEach((word) => {
              const regex = new RegExp(`(${word})`, "g");
              currentText = currentText.replace(
                regex,
                `<span style="color:${highlightColor}; font-weight:bold;">$1</span>`
              );
            });

            targetElement.innerHTML = currentText;
            index++;
            setTimeout(typeNextChar, 10);
          }
        }

        typeNextChar();
      });

      let clustersColored = false;

      function colorClusters() {
        const clusterColors = {
          A: "#FF4F79",
          B: "#008C76",
          C: "#FFB400",
          D: "#512B81",
          E: "#00A6FB",
          F: "#FF5700",
          G: "#7DCE82",
          H: "#C3423F",
        };

        nodes.forEach((node) => {
          if (!clustersColored) {
            node.originalColor = node.color || colors[node.type] || "black";
            node.color = clusterColors[node.cluster] || node.originalColor;
          } else {
            node.color = node.originalColor;
          }
        });

        clustersColored = !clustersColored;
        update();
      }

      const nodes = [
        {
          id: 1,
          type: "report",
          cluster: "H",
          label:
            "Nvidia (NVDA) – Buy: Strong AI and GPU growth support a $950 target (vs. $850). Risks include supply chain issues and competition, but momentum remains strong.  ",
        },
        {
          id: 2,
          type: "firm",
          cluster: "H",
          logo: "st",
          label: "Santander",
        },
        { id: 3, type: "documentID", cluster: "H", label: "Document 620078" },
        { id: 4, type: "analyst name", cluster: "H", label: "Alex Smith" },
        { id: 5, type: "firmID", cluster: "H", label: "Firm 917772" },
        { id: 6, type: "analystID", cluster: "H", label: "Analyst 587958" },
        { id: 49, type: "estimid", cluster: "H", label: "HISPANO" },

        {
          id: 7,
          type: "report",
          cluster: "D",
          label:
            "Apple (AAPL) – Buy: iPhone and services growth drive a $220 target (vs. $190). Risks include supply chain and regulatory pressures, but ecosystem strength supports upside.",
        },
        {
          id: 8,
          type: "firm",
          cluster: "D",
          logo: "rbc",
          label: "RBC Capital Markets (Royal Bank of Canada)",
        },
        { id: 9, type: "documentID", cluster: "D", label: "Document 919942" },
        { id: 10, type: "analyst name", cluster: "D", label: "Andrew Stevens" },
        { id: 11, type: "firmID", cluster: "D", label: "Firm 116939" },
        { id: 12, type: "analystID", cluster: "D", label: "Analyst 205348" },
        { id: 50, type: "estimid", cluster: "D", label: "RBCDOMIN" },

        {
          id: 13,
          type: "report",
          cluster: "C",
          label:
            "Tesla (TSLA) – Hold: EV leadership intact, but demand concerns cap upside at $190 (vs. $195). Energy and autonomy offer potential, but volatility remains.",
        },
        { id: 14, type: "firm", cluster: "C", logo: "hsbc", label: "HSBC" },
        { id: 15, type: "documentID", cluster: "C", label: "Document 868846" },
        { id: 16, type: "analyst name", cluster: "C", label: "Taylor Brown" },
        { id: 17, type: "firmID", cluster: "C", label: "Firm 876060" },
        { id: 18, type: "analystID", cluster: "C", label: "Analyst 665024" },
        { id: 51, type: "estimid", cluster: "C", label: "CAPELEUR" },

        {
          id: 19,
          type: "report",
          cluster: "B",
          label:
            "Microsoft (MSFT) – Buy: Azure and AI growth drive a $450 target (vs. $420). Regulatory risks persist, but enterprise dominance keeps outlook strong.",
        },
        {
          id: 20,
          type: "firm",
          cluster: "B",
          logo: "jpm",
          label: "JP Morgan",
        },
        { id: 21, type: "documentID", cluster: "B", label: "Document 928791" },
        {
          id: 22,
          type: "analyst name",
          cluster: "B",
          label: "Morgan Williams",
        },
        { id: 23, type: "firmID", cluster: "B", label: "Firm 719925" },
        { id: 24, type: "analystID", cluster: "B", label: "Analyst 141805" },
        { id: 52, type: "estimid", cluster: "B", label: "JPMORGAN" },

        {
          id: 25,
          type: "report",
          cluster: "E",
          label:
            "Amazon (AMZN) – Buy: AWS and cost efficiencies support a $200 target (vs. $180). Macro risks remain, but e-commerce and cloud growth provide upside.",
        },
        {
          id: 26,
          type: "firm",
          cluster: "E",
          logo: "barclays",
          label: "Barclays",
        },
        { id: 27, type: "documentID", cluster: "E", label: "Document 371780" },
        { id: 28, type: "analyst name", cluster: "E", label: "Michael Walker" },
        { id: 29, type: "firmID", cluster: "E", label: "Firm 320537" },
        { id: 30, type: "analystID", cluster: "E", label: "Analyst 902060" },
        { id: 53, type: "estimid", cluster: "E", label: "FRCLAYSC" },

        {
          id: 31,
          type: "report",
          cluster: "F",
          label:
            "Meta (META) – Hold: Ad strength and AI investments push a $480 target (vs. $470). Metaverse spending is uncertain, and competition remains a challenge.",
        },
        {
          id: 32,
          type: "firm",
          cluster: "F",
          logo: "bofa",
          label: "BofA Global Research (Bank of America)",
        },
        { id: 33, type: "documentID", cluster: "F", label: "Document 610230" },
        { id: 34, type: "analyst name", cluster: "F", label: "Riley Davis" },
        { id: 35, type: "firmID", cluster: "F", label: "Firm 554181" },
        { id: 36, type: "analystID", cluster: "F", label: "Analyst 652639" },
        { id: 54, type: "estimid", cluster: "F", label: "MERRILL" },

        {
          id: 37,
          type: "report",
          cluster: "G",
          label:
            "Alphabet (GOOGL) – Buy: Search, YouTube, and AI fuel a $170 target (vs. $155). Regulatory risks persist, but business diversification supports growth.",
        },
        {
          id: 38,
          type: "firm",
          cluster: "G",
          logo: "de",
          label: "Deutsche Bank",
        },
        { id: 39, type: "documentID", cluster: "G", label: "Document 842886" },
        { id: 40, type: "analyst name", cluster: "G", label: "Jamie Miller" },
        { id: 41, type: "firmID", cluster: "G", label: "Firm 896998" },
        { id: 42, type: "analystID", cluster: "G", label: "Analyst 195423" },
        { id: 55, type: "estimid", cluster: "G", label: "LAWRENCE" },

        {
          id: 43,
          type: "report",
          cluster: "A",
          label:
            "Airbnb (ABNB) – Hold: Strong brand and global travel demand support a $170 target (vs. $160). Resilient booking trends and margin expansion drive growth, but regulatory challenges and macroeconomic conditions remain key risks.",
        },
        {
          id: 44,
          type: "firm",
          cluster: "A",
          logo: "gs",
          label: "Goldman Sachs",
        },
        { id: 45, type: "documentID", cluster: "A", label: "Document 616385" },
        { id: 46, type: "analyst name", cluster: "A", label: "James Matthews" },
        { id: 47, type: "firmID", cluster: "A", label: "Firm 251906" },
        { id: 48, type: "analystID", cluster: "A", label: "Analyst 370097" },
        { id: 56, type: "estimid", cluster: "A", label: "GOLDMAN" },
      ];

      const buttonGroups = {
        1: ["A"],
        2: ["B"],
        3: ["C", "D"],
        4: ["E", "F", "G", "H"],
      };

      function getButtonColor(buttonIndex) {
        const colors = {
          1: "#704bfe",
          2: "#3a86ff",
          3: "#ff924c",
          4: "#4cd38a",
        };
        return colors[buttonIndex] || "#ddd";
      }

      function updateButtonStates() {
        let totalClusters = 8;

        let formedClusters = new Set();

        Object.keys(buttonGroups).forEach((buttonIndex) => {
          const button = document.querySelector(
            `.tab:nth-child(${buttonIndex})`
          );
          const clusters = buttonGroups[buttonIndex];

          const allClustersApplied = clusters.every((cluster) =>
            nodes.some(
              (node) =>
                node.cluster === cluster &&
                node.targetX !== null &&
                node.targetY !== null
            )
          );

          if (allClustersApplied) {
            button.style.backgroundColor = getButtonColor(buttonIndex);
            clusters.forEach((cluster) => formedClusters.add(cluster));
          } else {
            button.style.backgroundColor = "#ccc";
            clusters.forEach((cluster) => {
              if (
                nodes.some(
                  (node) =>
                    node.cluster === cluster &&
                    node.targetX !== null &&
                    node.targetY !== null
                )
              ) {
                formedClusters.add(cluster);
              }
            });
          }
        });

        let percentage = (formedClusters.size / totalClusters) * 100;

        animatePercentage(percentage);
      }

      document.querySelectorAll(".tab").forEach((button, index) => {
        const buttonIndex = index + 1;
        if (buttonIndex <= 4) {
          button.style.backgroundColor = "#ccc";

          button.addEventListener("mouseover", () => {
            button.style.backgroundColor = getButtonColor(buttonIndex);
          });

          button.addEventListener("mouseleave", () => {
            if (
              !buttonGroups[buttonIndex].some((cluster) =>
                nodes.some(
                  (node) =>
                    node.cluster === cluster &&
                    node.targetX !== null &&
                    node.targetY !== null
                )
              )
            ) {
              button.style.backgroundColor = "#ccc";
            }
          });
        }
      });

      function formClusters(groupSet) {
        computeClusterCenters();
        clustering = true;

        nodes.forEach((node) => {
          if (groupSet.includes(node.cluster)) {
            let center = clusterCenters[node.cluster];
            node.targetX = center.x + Math.random() * 40 - 20;
            node.targetY = center.y + Math.random() * 40 - 20;
          }
        });

        updateButtonStates();
        setTimeout(updateButtonStates, 500);
      }

      function toggleDarkMode() {
        document.body.classList.toggle("dark-mode");

        let darkModeIcon = document.getElementById("darkModeIcon");
        if (document.body.classList.contains("dark-mode")) {
          darkModeIcon.src = "icons/sun.png";
        } else {
          darkModeIcon.src = "icons/moon.png";
        }

        update();
      }

      function resetCluster(cluster) {
        clustering = false;

        nodes.forEach((node) => {
          if (node.cluster === cluster) {
            node.x = node.originalX;
            node.y = node.originalY;

            node.targetX = null;
            node.targetY = null;
          }
        });

        updateButtonStates();
      }

      canvas.addEventListener("click", (event) => {
        let rect = canvas.getBoundingClientRect();
        let mouseX = event.clientX - rect.left;
        let mouseY = event.clientY - rect.top;

        nodes.forEach((node) => {
          let dx = node.x - mouseX;
          let dy = node.y - mouseY;
          let distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < 15) {
            resetCluster(node.cluster);
          }
        });
      });

      function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
        let words = text.split(" ");
        let line = "";
        let lines = [];

        for (let i = 0; i < words.length; i++) {
          let testLine = line + words[i] + " ";
          let testWidth = ctx.measureText(testLine).width;
          if (testWidth > maxWidth && i > 0) {
            lines.push(line);
            line = words[i] + " ";
          } else {
            line = testLine;
          }
        }
        lines.push(line);

        for (let i = 0; i < lines.length; i++) {
          ctx.fillText(lines[i], x, y + i * lineHeight);
        }
      }

      canvas.addEventListener("mousedown", (event) => {
        let rect = canvas.getBoundingClientRect();
        let mouseX = event.clientX - rect.left;
        let mouseY = event.clientY - rect.top;

        draggingNode = null;

        nodes.forEach((node) => {
          let dx = node.x - mouseX;
          let dy = node.y - mouseY;
          let distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < 15 && node.targetX === null && node.targetY === null) {
            draggingNode = node;
            offsetX = dx;
            offsetY = dy;
          }
        });
      });

      let clusterCenters = {};
      let hoveredNode = null;
      let clustering = false;
      let margin = 20;

      nodes.forEach((node) => {
        node.x = Math.random() * (canvas.width - 2 * margin) + margin;
        node.y = Math.random() * (canvas.height - 2 * margin) + margin;
        node.vx = (Math.random() - 0.5) * 1.25;
        node.vy = (Math.random() - 0.5) * 1.25;
        node.targetX = null;
        node.targetY = null;
      });

      function drawGrid() {
        ctx.strokeStyle = "rgba(125, 125, 125, 0.75)";
        ctx.lineWidth = 0.25;
        ctx.setLineDash([2, 2]);

        let gridSize = 25;

        ctx.beginPath();
        for (let x = 0; x < canvas.width; x += gridSize) {
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
        }
        for (let y = 0; y < canvas.height; y += gridSize) {
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
      }

      function computeClusterCenters() {
        let clusters = {};

        nodes.forEach((node) => {
          if (!clusters[node.cluster]) {
            clusters[node.cluster] = { sumX: 0, sumY: 0, count: 0 };
          }
          clusters[node.cluster].sumX += node.x;
          clusters[node.cluster].sumY += node.y;
          clusters[node.cluster].count++;
        });

        Object.keys(clusters).forEach((cluster) => {
          let avgX = clusters[cluster].sumX / clusters[cluster].count;
          let avgY = clusters[cluster].sumY / clusters[cluster].count;

          let padding = 50;
          clusterCenters[cluster] = {
            x: Math.min(Math.max(avgX, padding), canvas.width - padding),
            y: Math.min(Math.max(avgY, padding), canvas.height - padding),
          };
        });
      }

      function update() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();

        nodes.forEach((node) => {
          let size = 20;
          let radius = 5;

          if (clustering && node.targetX !== null && node.targetY !== null) {
            node.x += (node.targetX - node.x) * 0.1;
            node.y += (node.targetY - node.y) * 0.1;
          }

          ctx.save();
          drawRoundedRect(
            ctx,
            node.x - size / 2,
            node.y - size / 2,
            size,
            size,
            radius
          );
          ctx.clip();

          ctx.fillStyle = node.color || colors[node.type] || "black";
          ctx.fill();

          ctx.restore();
        });

        if (hoveredNode) {
          let maxTextWidth = 200;
          let lineHeight = 16;
          let paddingX = 8;
          let paddingY = 4;
          ctx.font = "14px 'GeistMono', monospace";

          let singleLineWidth = ctx.measureText(hoveredNode.label).width;

          let needsWrapping = singleLineWidth > maxTextWidth;

          let words = hoveredNode.label.split(" ");
          let lines = [];
          let line = "";
          let longestLineWidth = 0;

          if (needsWrapping) {
            for (let i = 0; i < words.length; i++) {
              let testLine = line + words[i] + " ";
              let testWidth = ctx.measureText(testLine).width;

              if (testWidth > maxTextWidth && line.length > 0) {
                lines.push(line.trim());
                longestLineWidth = Math.max(
                  longestLineWidth,
                  ctx.measureText(line).width
                );
                line = words[i] + " ";
              } else {
                line = testLine;
              }
            }
            lines.push(line.trim());
            longestLineWidth = Math.max(
              longestLineWidth,
              ctx.measureText(line).width
            );
          } else {
            lines.push(hoveredNode.label);
            longestLineWidth = singleLineWidth;
          }

          let textWidth = Math.min(maxTextWidth, longestLineWidth);

          let textHeight = lines.length * lineHeight + paddingY * 2;

          let tooltipX = hoveredNode.x + 10;
          let tooltipY = hoveredNode.y - textHeight - 5;

          ctx.shadowColor = "rgba(0, 0, 0, 0.2)";
          ctx.shadowBlur = 4;

          ctx.fillStyle = "rgba(255, 255, 255, 0.95)";
          ctx.fillRect(
            tooltipX,
            tooltipY,
            textWidth + paddingX * 2,
            textHeight
          );

          ctx.shadowBlur = 0;

          ctx.fillStyle = "black";
          for (let i = 0; i < lines.length; i++) {
            ctx.fillText(
              lines[i],
              tooltipX + paddingX,
              tooltipY + paddingY + (i + 0.75) * lineHeight
            );
          }

          ctx.setLineDash([3, 3]);
          ctx.strokeStyle = "lightgray";
          ctx.lineWidth = 1;
          ctx.beginPath();
          nodes.forEach((node) => {
            if (node.cluster === hoveredNode.cluster) {
              ctx.moveTo(hoveredNode.x, hoveredNode.y);
              ctx.lineTo(node.x, node.y);
            }
          });
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.lineWidth = 0;
        }

        function drawRoundedRect(ctx, x, y, width, height, radius) {
          ctx.beginPath();
          ctx.moveTo(x + radius, y);
          ctx.lineTo(x + width - radius, y);
          ctx.arcTo(x + width, y, x + width, y + radius, radius);
          ctx.lineTo(x + width, y + height - radius);
          ctx.arcTo(
            x + width,
            y + height,
            x + width - radius,
            y + height,
            radius
          );
          ctx.lineTo(x + radius, y + height);
          ctx.arcTo(x, y + height, x, y + height - radius, radius);
          ctx.lineTo(x, y + radius);
          ctx.arcTo(x, y, x + radius, y, radius);
          ctx.closePath();
        }

        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            let nodeA = nodes[i];
            let nodeB = nodes[j];

            let dx = nodeB.x - nodeA.x;
            let dy = nodeB.y - nodeA.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            let minDist = 20;

            if (distance < minDist) {
              let overlap = minDist - distance;
              let angle = Math.atan2(dy, dx);

              let moveX = (overlap / 2) * Math.cos(angle);
              let moveY = (overlap / 2) * Math.sin(angle);

              nodeA.x -= moveX;
              nodeA.y -= moveY;
              nodeB.x += moveX;
              nodeB.y += moveY;

              [nodeA.vx, nodeB.vx] = [nodeB.vx, nodeA.vx];
              [nodeA.vy, nodeB.vy] = [nodeB.vy, nodeA.vy];
            }
          }
        }

        requestAnimationFrame(update);
      }

      nodes.forEach((node) => {
        node.originalX = node.x;
        node.originalY = node.y;
      });

      function scatterNodes() {
        clustering = false;

        let margin = 20;

        nodes.forEach((node) => {
          node.x = Math.random() * (canvas.width - 2 * margin) + margin;
          node.y = Math.random() * (canvas.height - 2 * margin) + margin;
          node.targetX = null;
          node.targetY = null;
        });
        updateButtonStates();
      }

      const clusterInfoBox = document.getElementById("cluster-info-box");

      canvas.addEventListener("mousemove", (event) => {
        let rect = canvas.getBoundingClientRect();
        let mouseX = event.clientX - rect.left;
        let mouseY = event.clientY - rect.top;

        if (draggingNode) {
          draggingNode.x = mouseX + offsetX;
          draggingNode.y = mouseY + offsetY;
        } else {
          hoveredNode = null;
          let hoveredCluster = null;

          nodes.forEach((node) => {
            let dx = node.x - mouseX;
            let dy = node.y - mouseY;
            let distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 15) {
              hoveredNode = node;
              hoveredCluster = node.cluster;
            }
          });

          const cleanLabel = (type, label) => {
            let prefixPatterns = {
              documentID: /^Document\s+/i,
              firmID: /^Firm\s+/i,
              analystID: /^Analyst\s+/i,
            };

            if (prefixPatterns[type]) {
              return label.replace(prefixPatterns[type], "");
            }
            return label;
          };

          if (hoveredCluster) {
            let clusterNodes = nodes.filter(
              (node) => node.cluster === hoveredCluster
            );
            let clusterText = ``;

            let primaryOrder = ["firm", "report", "documentID", "analyst name"];
            let secondaryOrder = ["estimid", "firmID", "analystID"];

            const formatLabel = (type) =>
              type.replace(/([a-z])([A-Z])/g, "$1 $2");

            const appendNodes = (orderArray) => {
              orderArray.forEach((type) => {
                let node = clusterNodes.find((n) => n.type === type);
                if (node) {
                  let cleanedLabel = cleanLabel(type, node.label);
                  let color = document.body.classList.contains("dark-mode")
                    ? "white"
                    : "black";
                  if (
                    ["A", "B"].includes(hoveredCluster) &&
                    (type === "firm" || type === "estimid")
                  ) {
                    color = "#50C878";
                  }

                  if (
                    ["C", "D", "E", "F", "G", "H"].includes(hoveredCluster) &&
                    (type === "firm" || type === "estimid")
                  ) {
                    color = "#DC143C";
                  }

                  clusterText += `<strong style="font-weight: bold;">${formatLabel(
                    type
                  ).toUpperCase()}:</strong> <span style="color:${color}!important">${cleanedLabel}</span><br>`;
                }
              });
            };

            appendNodes(primaryOrder);
            let targetPercentage;
            let similarityText;

            if (hoveredCluster === "A") {
              targetPercentage = 57.97;
              similarityText = "Cosine similarity";
            } else if (hoveredCluster === "B") {
              targetPercentage = 88.89;
              similarityText = "Fuzzy similarity";
            } else if (["C", "D"].includes(hoveredCluster)) {
              targetPercentage = hoveredCluster === "C" ? 90.12 : 97.89;
              similarityText = "Structural similarity";
            } else if (["E", "F", "G", "H"].includes(hoveredCluster)) {
              let percentMap = { E: 79.01, F: 98.76, G: 81.35, H: 95.49 };
              targetPercentage = percentMap[hoveredCluster];
              similarityText = "Match likelihood";
            }
            clusterText += `
    <div class="loading-box">
      <div>${similarityText}:</div>
      <div class="loading-container" id="loading-bar-container">
        <div class="loading-bar" id="loading-bar"></div>
      </div>
      <div class="percent-text" id="percent-text">0.00%</div>
    </div><br>
  `;

            setTimeout(() => {
              let loadingBar = document.getElementById("loading-bar");
              let loadingContainer = document.getElementById(
                "loading-bar-container"
              );
              let percentText = document.getElementById("percent-text");

              if (loadingBar && loadingContainer && percentText) {
                loadingContainer.style.opacity = "1";

                let duration = 1000;
                let intervalTime = 20;
                let steps = duration / intervalTime;
                let increment = targetPercentage / steps;
                let currentPercent = 0;

                loadingBar.style.transition = `width ${duration}ms linear`;
                loadingBar.style.width = `${targetPercentage}%`;

                let interval = setInterval(() => {
                  if (currentPercent >= targetPercentage) {
                    clearInterval(interval);
                    percentText.textContent = `${targetPercentage.toFixed(2)}%`;
                  } else {
                    currentPercent += increment;
                    percentText.textContent = `${currentPercent.toFixed(2)}%`;
                  }
                }, intervalTime);
              }
            }, 100);

            appendNodes(secondaryOrder);

            clusterInfoBox.innerHTML = clusterText;
            clusterInfoBox.style.opacity = "1";
            clusterInfoBox.style.visibility = "visible";
          } else {
            clusterInfoBox.style.opacity = "0";
            clusterInfoBox.style.visibility = "hidden";
          }
        }
      });

      clusterInfoBox.addEventListener("mouseleave", () => {
        let loadingBar = document.getElementById("loading-bar");
        let loadingContainer = document.getElementById("loading-bar-container");

        if (loadingBar && loadingContainer) {
          loadingBar.style.width = "0%";
          loadingContainer.style.opacity = "0";
        }
      });

      canvas.addEventListener("mouseup", () => {
        if (draggingNode) {
          draggingNode.originalX = draggingNode.x;
          draggingNode.originalY = draggingNode.y;
        }
        draggingNode = null;
      });

      canvas.addEventListener("mouseleave", () => {
        draggingNode = null;
        hoveredNode = null;
      });
      canvas.addEventListener("mouseenter", () => {
        update();
      });

      update();
    </script>
  </body>
</html>
